import { useRef, useState } from "react";
import useGetChannelId from "@/hooks/use-get-channel-id";
import dynamic from "next/dynamic";
import Quill from "quill";
import { ConvexError } from "convex/values";
import { differenceInMinutes, format, isToday, isYesterday } from "date-fns";

import useGetMessageById from "@/api/messages/use-get-message-by-id";
import useGetCurrentMembershipInfo from "@/api/membership-infos/use-get-current-membership-info";
import useGetWorkspaceId from "@/hooks/use-get-workspace-id";
import { useCreateMessage } from "@/api/messages/use-create-message";
import { useGenerateUploadUrl } from "@/api/upload/use-generate-upload-url";
import useGetMessages from "@/api/messages/use-get-message";

import Message from "../messages/message";
import { AlertTriangle, Loader, XIcon } from "lucide-react";
import { Id } from "../../../convex/_generated/dataModel";
import { Button } from "../ui/button";
import { toast } from "sonner";

const Editor = dynamic(() => import("@/components/input/editor"), {
  ssr: false,
});

const MINUTE_THRESHOLD = 5;

type MessageSubmitType = {
  body: string;
  image?: File | null;
};

type CreateMessageValues = {
  channelId: Id<"channels">;
  workspaceId: Id<"workspaces">;
  parentMessageId: Id<"messages">;
  body: MessageSubmitType["body"];
  image: Id<"_storage"> | undefined;
};

interface ThreadProps {
  messageId: Id<"messages">;
  onClose: () => void;
}

function Thread(props: Readonly<ThreadProps>) {
  const { messageId, onClose } = props;

  const [editingId, setEditingId] = useState<Id<"messages"> | null>(null);
  const [editorKey, setEditorKey] = useState(0);
  const [isThreadPending, setIsThreadPending] = useState(false);
  const editorRef = useRef<Quill | null>(null);

  const channelId = useGetChannelId();
  const workspaceId = useGetWorkspaceId();
  const { membershipInfo: userMembershipInfo, isLoading: _ } =
    useGetCurrentMembershipInfo({ workspaceId: workspaceId });
  //message fetched here
  const { message, isLoading: isFetchingMessage } = useGetMessageById({
    messageId: messageId,
  });

  const { results, status, loadMore } = useGetMessages({
    channelId: channelId,
    parentMessageId: message?._id,
  });

  const canLoadMore = status === "CanLoadMore";
  const isLoadingMore = status === "LoadingMore";

  const groupedMessagesByDate = results?.reduce(
    (groups, message) => {
      const date = new Date(message!._creationTime);
      //key for grouping
      const dateKey = format(date, "yyyy-MM-dd");
      if (!groups[dateKey]) {
        groups[dateKey] = [];
      }
      groups[dateKey].unshift(message);
      return groups;
    },
    {} as Record<string, typeof results>
  );

  function formatDateLabel(dateString: string) {
    const date = new Date(dateString);
    if (isToday(date)) return "Today";
    if (isYesterday(date)) return "Yesterday";
    return format(date, "EEEE, MMMM d");
  }

  const {
    data: _messageId,
    mutateAsync: createMessage,
    error: messageError,
  } = useCreateMessage({
    onError: handleMessageError,
    onSuccess: handleMessageSuccess,
    onSettled: handleMessageSettled,
  });

  const {
    isPending: _isGeneratingUploadUrl,
    error: uploadUrlError,
    mutateAsync: generateUploadUrl,
  } = useGenerateUploadUrl({
    onError: handleGenerateUploadUrlError,
    onSettled: handleGenerateUploadUrlSettled,
  });

  function handleMessageError() {
    toast.error("Something went wrong in sending the message");
    console.log("error: ", messageError);
  }

  function handleMessageSuccess() {
    setEditorKey((e) => e + 1);
    setIsThreadPending(false);
  }

  function handleMessageSettled() {
    editorRef?.current?.enable(true);
    setIsThreadPending(false);
  }

  function handleGenerateUploadUrlError() {
    toast.error("Something went wrong in trying to upload the image");
    console.log("error: " + uploadUrlError);
  }

  function handleGenerateUploadUrlSettled() {
    setIsThreadPending(false);
  }

  async function handleSubmit(submitData: MessageSubmitType) {
    console.log(submitData);
    setIsThreadPending(true);
    editorRef?.current?.enable(false);

    const messageValues: CreateMessageValues = {
      parentMessageId: messageId,
      workspaceId: workspaceId,
      channelId: channelId,
      body: submitData.body,
      image: undefined,
    };

    if (submitData.image) {
      setIsThreadPending(true);
      const url = await generateUploadUrl({});

      try {
        //api call that requests to upload a file on the server of the url
        //the url is generated by convex thru the generateUploadUrl method
        const response = await fetch(url, {
          method: "POST",
          headers: {
            "Content-Type": submitData.image.type,
          },
          body: submitData.image,
        });

        if (!response.ok) {
          throw new ConvexError({
            message: "[client][upload image]: url not found",
          });
        }

        const { storageId } = await response.json();

        //when everything is successful, the image should be uploaded in the convex storage
        //and you can get the reference of that document through the response json
        messageValues.image = storageId;
      } catch (error) {
        toast.error("Something went wrong with uploading the image", {
          description: "error:" + error,
        });
      }
    }

    //send the messageValues as args to the convex api
    await createMessage(messageValues);
  }

  if (isFetchingMessage) {
    return (
      <div className="h-full flex flex-col">
        <div className="h-[49px] flex justify-between items-center px-4 border-b">
          <p className="text-lg font-bold">Thread</p>
          <Button onClick={onClose} size={"iconSm"} variant={"ghost"}>
            <XIcon className="size-5 stroke-[1.5]" />
          </Button>
        </div>
        <div className="flex flex-col h-full items-center justify-center gap-y-2 overflow-hidden">
          <Loader className="size-5 animate-spin text-muted-foreground" />
          <p className="text-sm text-center text-muted-foreground">
            {status === "LoadingFirstPage"
              ? "Fetching message details..."
              : "Fetching thread messages..."}
          </p>
        </div>
      </div>
    );
  }
  return (
    <div className="h-full flex flex-col">
      <div className="h-[49px] flex justify-between items-center px-4 border-b">
        <p className="text-lg font-bold">Thread</p>
        <Button onClick={onClose} size={"iconSm"} variant={"ghost"}>
          <XIcon className="size-5 stroke-[1.5]" />
        </Button>
      </div>
      {message ? (
        <>
          <div className="flex-1 flex flex-col-reverse pb-4 overflow-y-auto messages-scrollbar">
            {Object.entries(groupedMessagesByDate || {}).map(
              ([dateKey, messages]) => (
                <div key={dateKey}>
                  <div className="text-center my-2 relative">
                    <hr className="absolute top-1/2 left-0 right-0 border-t border-gray-300" />
                    <span className="relative inline-block bg-[#f5f5f5] px-4 py-1 rounded-full text-xs border border-gray-300 shadow-sm">
                      {formatDateLabel(dateKey)}
                    </span>
                  </div>
                  {messages.map((message, index) => {
                    const prevMessage = messages[index - 1];
                    const isCompact =
                      prevMessage &&
                      prevMessage.user?._id === message!.user?._id &&
                      differenceInMinutes(
                        new Date(message!._creationTime),
                        new Date(prevMessage._creationTime)
                      ) < MINUTE_THRESHOLD;

                    return (
                      <Message
                        key={message?._id}
                        messageId={message!._id}
                        membershipInfoId={message!.membershipInfoId}
                        authorName={message!.user.name}
                        authorImage={message!.user.image}
                        isAuthor={
                          message?.membershipInfoId === userMembershipInfo?._id
                        }
                        reactions={message!.reactions}
                        body={message!.body}
                        image={message!.image}
                        updatedAt={message!.updatedAt}
                        createdAt={message!._creationTime}
                        isEditing={editingId === message?._id}
                        setEditingId={setEditingId}
                        isCompact={isCompact}
                        hideThreadButton
                        threadCount={message!.threadCount}
                        threadImage={message!.threadImage}
                        threadTimestamp={message!.threadTimestamp}
                      />
                    );
                  })}
                </div>
              )
            )}
            <div
              className="h-1"
              //attaches a ref callback
              ref={(el) => {
                if (el) {
                  const observer = new IntersectionObserver(
                    ([entry]) => {
                      //isIntersecting means that the element being observed has entered the viewport
                      if (entry.isIntersecting && canLoadMore) {
                        loadMore();
                      }
                    },
                    {
                      threshold: 1.0, //triggers when 100% is intersecting (in the viewport)
                    }
                  );
                  //attaches the observer to the element
                  observer.observe(el);
                  return () => observer.disconnect(); //cleanup, disposes the observer
                }
              }}
            />
            {isLoadingMore && (
              <div className="text-center my-2 relative">
                <hr className="absolute top-1/2 left-0 right-0 border-t border-gray-300" />
                <span className="relative inline-block bg-[#f5f5f5] px-4 py-1 rounded-full text-xs border border-gray-300 shadow-sm">
                  <Loader className="size-4 animate-spin" />
                </span>
              </div>
            )}
            <Message
              hideThreadButton
              membershipInfoId={message.membershipInfoId}
              authorImage={message.user.image}
              authorName={message.user.name}
              isAuthor={message.membershipInfoId === userMembershipInfo?._id}
              body={message.body}
              isCompact={false}
              image={message.image}
              createdAt={message._creationTime}
              updatedAt={message.updatedAt}
              messageId={message._id}
              reactions={message.reactions}
              isEditing={editingId === message._id}
              setEditingId={setEditingId}
            />
          </div>

          <div className="px-4">
            <Editor
              key={editorKey}
              onSubmit={handleSubmit}
              innerRef={editorRef}
              disabled={isThreadPending}
              variant="create"
              placeholder="Reply..."
            />
          </div>
        </>
      ) : (
        <div className="flex flex-col h-full items-center justify-center">
          <AlertTriangle className="size-5 text-muted-foreground" />
          <p className="text-center text-sm text-muted-foreground">
            No messages found
          </p>
        </div>
      )}
    </div>
  );
}
export default Thread;
